# Part 3

Try running the app again (instructions in [Part 1](Part1.md)), and this time, instead of visiting the home page, try visiting `/movies`.  (That is: `/movies` should be the URI path, the part that immediately follows the hostname and/or port number in the URI.)

Or, for that matter, visit `/turtle` or `/foobar` or any URI path at all; Rails will complain that your URI doesn't match any route, because we haven’t specified any routes mapping URIs to app methods. Try `rails routes` in the terminal and verify that it informs us that there are no routes in our brand-new app. (You may want to open multiple Terminal windows or tabs so that the app can keep running while you try other commands.)

More importantly, use an editor to open the file `log/development.log` and observe that the error message is logged there; this is where you look to find detailed error information when something goes wrong.  We'll show other problem-finding and debugging techniques later.

To fix this error we need to add some routes. Since our initial goal is to store movie information in a database, we can take advantage of a Rails shortcut that creates RESTful routes for the four basic CRUD actions  (Create, Read, Update, Delete) on a model. (Recall that RESTful routes specify self-contained requests of what operation to perform and what entity, or resource, to perform it on.)

## Create CRUD routes

Edit `config/routes.rb`, which was auto-generated by the `rails new` command and is heavily commented. Replace the contents of the file with this code (the file is mostly comments, so you’re not actually deleting much).
```
Rails.application.routes.draw do
  resources :movies
  root :to => redirect('/movies')
end
```
resources :movies 是一個快捷方式，告訴 Rails 自動生成與 movies 資源相關的 RESTful 路由。它會自動為 movies 資源創建 7 種不同的路由，對應於以下的 CRUD 操作：
GET /movies：顯示所有電影（index 動作）。
GET /movies/:id：顯示特定電影的詳細資料（show 動作）。
GET /movies/new：顯示表單來創建新電影（new 動作）。
POST /movies：創建一個新電影（create 動作）。
GET /movies/:id/edit：顯示表單來編輯現有電影（edit 動作）。
PATCH/PUT /movies/:id：更新特定電影（update 動作）。
DELETE /movies/:id：刪除特定電影（destroy 動作）。

這行代碼定義了應用程式的根路徑（即 /）應該重定向到 /movies。也就是說，當使用者訪問應用程式的首頁時，會被自動轉向到電影列表頁面（/movies）。root :to => 用於指定應用程式的根路徑行為，而 redirect('/movies') 則執行了重定向操作。
    

The root is the initial page for your application, i.e. the path / . The right behavior depends on the design and use of your application. In RottenPotatoes, the Movies index is the simplest option, but in another application we might have a different action, such as rendering a marketing or login page.
<details><summary>Note</summary>It is best practice to not render the exact same content in two different routes, e.g. / and /movies. In Rails, you can choose to redirect the root URL to the <code>movies#index</code>, or you could write, <code>resources :movies, except: [:index]</code> to prevent /movies from being defined. Try modifying routes.rb then executing <code>rails routes</code> to see what changes!</details>

rails routes 命令的輸出是一個表格，包含以下信息：

Prefix：路由的前綴。這通常是命名路由，可以在控制器、視圖或其他地方使用 prefix_path 或 prefix_url 來生成對應的路徑或 URL。
Verb：HTTP 請求方法（如 GET、POST、PATCH、DELETE），這告訴你這個路由是基於哪種 HTTP 方法的請求。
URI Pattern：定義了這個路由對應的 URI 路徑。例如 /movies 或 /movies/:id。
Controller#Action：告訴你這個路由對應於哪個控制器的哪個動作。例如，movies#index 表示這個路由會調用 MoviesController 中的 index 動作。

Save the `routes.rb` file and run `rails routes` again, and observe that because of our change to `routes.rb`, the first line of output says that the URI `GET /movies` will try to call the `index` action of the `MoviesController`; this and most of the other routes in the table are the result of the line resources `:movies`, as we’ll soon see.  (As with many Rails methods, `resources 'movies'` would also work, but a symbol usually indicates one of a fixed set of choices rather than an arbitrary string.) The root route `'/'`, RottenPotatoes’ “home page,” will take us to the main Movie listings page by a mechanism we’ll soon see called a `URL redirection`.

(If you want more practice with how the routes.rb contents get parsed into routes, play around with the [Rails Routing Practice app](https://rails-routing-practice.herokuapp.com/) brought to you by ESaaS.)



Using convention over configuration, Rails will expect this controller’s actions to be defined in the class `MoviesController`, and if that class isn’t defined at application start time, Rails will try to load it from the file `app/controllers/movies_controller.rb`. Sure enough, if you now restart the server and reload the page in your browser, you should see a different error: `uninitialized constant MoviesController`. This is good news: Rails is essentially complaining that it can’t find the `MoviesController` class, but the fact that it’s even looking for that class tells us that our route is working correctly! As before, this error message and additional information are captured in the log file `log/development.log`.

## Create actions and views

To create both the controller file and associated views, we run the following command:
```
rails g scaffold_controller Movie title rating description release_date --skip-test
```
是用來生成 Movie 模型的控制器以及相關視圖的，並且跳過測試文件的生成。讓我們分解來詳細解釋每個部分：

分解解釋：
rails g / rails generate：
這是 Rails 的生成器命令，用於自動生成模板代碼。g 是 generate 的簡寫，可以生成控制器、模型、遷移、視圖等文件。
scaffold_controller：
這個子命令會生成一個控制器以及與該控制器相關的視圖，用來執行基本的 CRUD 操作（Create, Read, Update, Delete）。和 scaffold 不同的是，這只會生成控制器和視圖，不會生成模型或遷移。
Movie：
這是你要生成的控制器的名稱。Rails 使用約定優於配置的原則，會將 Movie 自動映射為 movies_controller.rb（控制器名稱的複數形式）文件，並生成相關的動作（例如 index、show、new、edit 等）。
title rating description release_date：
這些是 Movie 模型中包含的欄位名稱。Rails 會根據這些欄位自動生成表單和視圖，用來顯示、編輯和創建這些欄位的數據。
--skip-test：
這個選項告訴 Rails 不要生成測試文件。如果你不需要為這個控制器生成測試代碼，這個選項可以避免生成不必要的文件。

Notice the command above lists the model name (ie Movie) followed by the fields in movie records (ie title, rating, description and release date).

The `rails g` / `rails generate` commands provide a number of useful methods that can auto-generate scaffolding for basic `CRUD+I` operations. You can check the list of all available commands on using `rails g --help`. Now you should have a working application even though the styling does not look too appealing. To make the page more appealing, you need to incorporate CSS. You will see this in later assignments.


Now that the app is working, we would like to deploy it to production.

## Summary

You’ve used the following commands to set up a new Rails app:

1. `rails new` sets up the new app; the `rails` command also has subcommands to run the app locally (`rails server`) and other management tasks.

2. Rails and the other gems your app depends on (we added the Haml templating) are listed in the app’s `Gemfile`, which Bundler uses to automate the process of creating a consistent environment for your app whether in development or production mode.

3. You created a database by running an initial migration to create the first table, then adding seed data in `seeds.rb` to populate the first few entries.  (In a real production app, you might or might not need seed data; usually it's used for things like creating the initial Admin account so that someone can login.)

4. To add routes in `config/routes.rb`, the one-line `resources` method provided by the Rails routing system allowed us to set up a group of related routes for `CRUD+Index` actions on a RESTful resource (REST = Representational State Transfer). The log files in the log directory collect error information when something goes wrong. You may have noticed that after changing routes.rb, you didn’t have to stop and restart the app in order for the changes to take effect.  In development mode, Rails reloads all of the app’s classes on every new request, so that your changes take effect immediately.  In production this would cause serious performance problems, so Rails provides ways to change various app behaviors between development and production mode.

5. Then, we took advantage of Rails's scaffolding to automatically generate (extremely simple) code for a controller and views that actually implement the CRUD+I RESTful actions.

In the final part, we'll deploy the app to a production-quality PaaS (Platform as a Service) in the cloud, namely Heroku.

<details>
    <summary>
        Recall the generic Rails welcome page you saw when you first created the app. In the <code>development.log</code> file, what is happening when the line that starts with GET “assets/rails.png” is printed? (Hint: recall the steps needed to render a page containing embedded assets.)
    </summary>
    <blockquote>
        The browser is requesting the embedded image of the Rails logo for the welcome page.
    </blockquote>
</details>

## Next
[Part 4](Part4.md)
